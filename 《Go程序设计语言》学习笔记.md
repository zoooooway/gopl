# 《Go程序设计语言》学习笔记

## 程序结构
### 变量
简短变量声明语句中必须至少要声明一个新的变量.
```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```
**简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量**。
```go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile) // 此时，这条语句会给上面声明的err变量赋值

if true {
    err := "new err" // 此时这条语句会在当前词法域重新声明一个变量并赋值
}
```

#### 指针
如果用`var x int`声明语句声明一个x变量，那么`&x`表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是`*int`，指针被称之为"指向int类型的指针"。如果指针名字为p，那么可以说"p指针指向变量x"，或者说"p指针保存了x变量的内存地址"。同时`*p`表达式对应p指针指向的变量的值。一般`*p`表达式读取指针指向的变量的值，这里为int类型的值，同时因为`*p`对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。
```go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```
变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&取地址操作。
```go
arr := [...]int{1, 2, 3, 4, 5}
s := arr[:]
reverseNew(&(arr[:])) // compile error: invalid operation: cannot take address of arr[:] (value of type []int)
reverseNew(&s)
```


### 赋值
自增和自减是语句，而不是表达式，因此`x = i++`之类的表达式是错误的。


## 基本数据类型
> 之前的章节忘记写了，那就从现在开始吧

### string
* 一个字符串是一个**不可改变**的字节序列。
* 内置的`len`函数可以返回一个字符串中的**字节**数目（不是rune字符数目）。
* 一个原生的字符串面值形式是 \`...\`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（在原生字符串面值内部是无法直接写 \` 字符的，可以用八进制或十六进制转义或 + "`" 连接字符串常量完成）。
    ```go
    const GoUsage = `Go is a tool for managing Go source code.

    Usage:
        go command [arguments]
    ...`
    ```

* 通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思。
* Go语言的`range`循环在处理字符串的时候，会**自动隐式解码**UTF8字符串。（注意观察索引的变化，需要注意的是对于非ASCII，索引更新的步长将超过1个字节）
  ![alt range循环字符串时的示意图](https://raw.githubusercontent.com/zoooooway/picgo/master/ch3-05.png)
* 当向`bytes.Buffer`添加任意字符的UTF8编码时，最好使用`bytes.Buffer`的`WriteRune`方法，但是`WriteByte`方法对于写入类似 '[' 和 ']' 等ASCII字符则会更加有效。

### 常量
* 常量表达式的值在编译期计算，而不是在运行期。
* 每种常量的潜在类型都是基础类型：boolean、string或数字。（这意味这常量不能声明引用数据类型）
* 许多常量并没有一个明确的基础类型，编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。
* **只有常量可以是无类型的。**
* 不同写法的常量除法表达式可能对应不同的结果：
    ```go
    var f float64 = 212
    fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 is a float64
    fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 is an untyped integer, 0
    fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 is an untyped float
    ```
* 当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。

    ```go
    var f float64 = 3 + 0i // untyped complex -> float64
    f = 2                  // untyped integer -> float64
    f = 1e123              // untyped floating-point -> float64
    f = 'a'                // untyped rune -> float64
    ```
    上面的语句相当于:
    ```go
        var f float64 = float64(3 + 0i)
        f = float64(2)
        f = float64(1e123)
        f = float64('a')
    ```
* **无类型整数常量转换为int，它的内存大小是不确定的**，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。
#### 常量生成器iota
在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。

```go
// e.g.
const (
    _ = 1 << (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 << 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 << 64)
    YiB // 1208925819614629174706176
)
```


## 复合数据类型
复合数据类型是以不同的方式组合基本类型而构造出来的。

数组和结构体是聚合类型，它们的值由许多元素或成员字段的值组成。数组是由同构的元素组成——**每个数组元素都是完全相同的类型**——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。

### 数组
数组是一个由**固定长度**的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。
数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。

可通过字面量形式初始化数组。默认情况下，数组的每个元素都被初始化为元素类型对应的零值。
```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
// 如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。
c := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"

// 没有用到的索引可以省略，下面表示索引为99处的元素为-1，因此其他的元素为默认零值
r := [...]int{99: -1}
```
### Slice
Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。
一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。

**一个slice由三个部分构成：指针、长度和容量**。**指针指向第一个slice元素对应的底层数组元素的地址**，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。

![alt slice和数组](https://raw.githubusercontent.com/zoooooway/picgo/master/ch4-01.png)

slice的切片操作`s[i:j]`，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从**第i个元素开始到第j-1个元素的子序列**。 新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用`len(s)`代替。

**和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素**。

一个零值的slice等于`nil`。一个`nil`值的slice并没有底层数组。一个`nil`值的slice的长度和容量都是0，但是也有非`nil`值的slice的长度和容量也是0的，例如`[]int{}`或`make([]int, 3)[3:]`。
与任意类型的`nil`值一样，我们可以**用`[]int(nil)`类型转换表达式来生成一个对应类型slice的`nil`值**。
```go
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
```

**如果你需要测试一个slice是否是空的，使用`len(s) == 0`来判断，而不应该用`s == nil`来判断**。除了和`nil`相等比较外，一个`nil`值的slice的行为和其它任意0长度的slice一样；例如reverse(`nil`)也是安全的。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待`nil`值的slice和0长度的slice。

内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。
```go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```
**在底层，make创建了一个匿名的数组变量**，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。

#### append函数
内置的append函数用于向slice追加元素。

**通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间**。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量：
```go
runes = append(runes, r)
```
> 对于append函数，当slice所对应的底层数组不足以容纳新元素时，内存可能重新分配(为slice创建新的底层数组空间)，但我们不能确认此操作是否发生。